{"version":3,"file":"commands.js","mappings":"oBAMA,MACMA,EAAY,8DA+RmBC,EAAOC,UAC1CD,EAAOC,QAAU,CACfC,aAzRJC,eAA4BC,EAAaC,GACvC,MAAM,UAAEC,EAAS,MAAEC,EAAK,SAAEC,EAAQ,QAAEC,GAAYL,GAC1C,QAAEM,EAAO,KAAEC,EAAI,eAAEC,EAAc,cAAEC,EAAa,iBAAEC,GACpDT,EAGIU,EAAS,WAAWT,wBAGpBU,EAAU,CACdC,OAAQ,CACNP,QAASA,EACTQ,QAAS,CACPP,KAAMA,EACNQ,UAAWR,EACXS,QAAQ,GAEVC,UAAW,CACTd,MAAOK,EACPU,KAAMT,KAMRJ,IACFO,EAAQC,OAAOM,SAAWC,SAASf,EAAS,KAI1CK,GAAoBA,EAAiBW,OAAS,IAChDT,EAAQC,OAAOC,QAAQQ,QAAUZ,GAInC,MAAMa,EAAaC,KAAK,GAAGrB,WAAeC,KAE1C,IACE,MAAMqB,EAAe,CACnBC,OAAQ,OACRC,QAAS,CACP,eAAgB,mBAChBC,cAAe,SAASL,KAE1BhB,KAAMsB,KAAKC,UAAUlB,IAIvB,IAAImB,EAAWpB,EAEboB,EAAWpC,EACX8B,EAAaE,QAAQ,gBAAkBhB,EAGzC,MAAMqB,QAAiBC,MAAMF,EAAUN,GAEvC,IAAKO,EAASE,GAAI,CAChB,MAAMC,QAAkBH,EAASI,OACjC,MAAM,IAAIC,MAAM,sBAAsBL,EAASM,YAAYH,IAC7D,CAGA,aADqBH,EAASO,MAEhC,CAAE,MAAOC,GAEP,MADAC,QAAQD,MAAM,iCAAkCA,GAC1CA,CACR,CACF,EAuNIE,mBA9MJ3C,eAAkCC,EAAa2C,EAAUC,GACvD,MAAM,UAAE1C,EAAS,MAAEC,EAAK,SAAEC,GAAaJ,GACjC,KAAEO,EAAI,iBAAEG,GAAqBkC,EAG7BjC,EAAS,WAAWT,oBAA4ByC,SAGhD/B,EAAU,CACdC,OAAQ,CACNC,QAAS,CACPP,KAAMA,EACNQ,UAAWR,EACXS,QAAQ,KAMVN,GAAoBA,EAAiBW,OAAS,IAChDT,EAAQC,OAAOC,QAAQQ,QAAUZ,GAInC,MAAMa,EAAaC,KAAK,GAAGrB,WAAeC,KAE1C,IACE,MAAMqB,EAAe,CACnBC,OAAQ,MACRC,QAAS,CACP,eAAgB,mBAChBC,cAAe,SAASL,KAE1BhB,KAAMsB,KAAKC,UAAUlB,IAIvB,IAAImB,EAAWpB,EAEboB,EAAWpC,EACX8B,EAAaE,QAAQ,gBAAkBhB,EAGzC,MAAMqB,QAAiBC,MAAMF,EAAUN,GAEvC,IAAKO,EAASE,GAAI,CAChB,MAAMC,QAAkBH,EAASI,OACjC,MAAM,IAAIC,MAAM,sBAAsBL,EAASM,YAAYH,IAC7D,CAGA,aADqBH,EAASO,MAEhC,CAAE,MAAOC,GAEP,MADAC,QAAQD,MAAM,0CAA2CA,GACnDA,CACR,CACF,EAuJIK,iBA/IJ9C,eAAgCC,EAAa8C,GAC3C,MAAM,UAAE5C,EAAS,MAAEC,EAAK,SAAEC,GAAaJ,GACjC,SAAE+C,EAAQ,QAAEC,GAAYF,EAGxBnC,EAAS,WAAWT,kCAA0C+C,mBAClEF,KAIIxB,EAAaC,KAAK,GAAGrB,WAAeC,KAE1C,IAEE,IAAI8C,EACJ,GAAuB,iBAAZF,EAAsB,CAE/B,MAAMG,EAAeC,KAAKJ,GACpBK,EAAQ,IAAIC,WAAWH,EAAa9B,QAC1C,IAAK,IAAIkC,EAAI,EAAGA,EAAIJ,EAAa9B,OAAQkC,IACvCF,EAAME,GAAKJ,EAAaK,WAAWD,GAErCL,EAAgBG,CAClB,MACEH,EAAgBF,EAGlB,MAAMvB,EAAe,CACnBC,OAAQ,OACRC,QAAS,CACPC,cAAe,SAASL,IACxB,eAAgB,sBAElBhB,KAAM2C,GAIR,IAAInB,EAAWpB,EAEboB,EAAWpC,EACX8B,EAAaE,QAAQ,gBAAkBhB,EAGzC,MAAMqB,QAAiBC,MAAMF,EAAUN,GAEvC,IAAKO,EAASE,GAAI,CAChB,MAAMC,QAAkBH,EAASI,OACjC,MAAM,IAAIC,MACR,gCAAgCL,EAASM,YAAYH,IAEzD,CAGA,aADqBH,EAASO,QAChBkB,OAAOC,KACvB,CAAE,MAAOlB,GAEP,MADAC,QAAQD,MAAM,8BAA+BA,GACvCA,CACR,CACF,EAsFImB,eA/EJ5D,eAA8BC,GAC5B,MAAM,UAAEE,EAAS,MAAEC,EAAK,SAAEC,GAAaJ,EAIjCW,EAAS,WAAWT,yBAEpBqB,EAAaC,KAAK,GAAGrB,WAAeC,KAE1C,IACE,MAAMqB,EAAe,CACnBC,OAAQ,MACRC,QAAS,CACPC,cAAe,SAASL,MAK5B,IAAIQ,EAAWpB,EAQf,OANEoB,EAAWpC,EACX8B,EAAaE,QAAQ,gBAAkBhB,SAGlBsB,MAAMF,EAAUN,IAEvBS,EAClB,CAAE,MAAOM,GAEP,OADAC,QAAQD,MAAM,oCAAqCA,IAC5C,CACT,CACF,EAiDIoB,YA1CJ7D,eAA2BC,GACzB,MAAM,UAAEE,EAAS,MAAEC,EAAK,SAAEC,GAAaJ,EAEjCW,EAAS,WAAWT,uBACpBqB,EAAaC,KAAK,GAAGrB,WAAeC,KAE1C,IACE,MAAMqB,EAAe,CACnBC,OAAQ,MACRC,QAAS,CACPC,cAAe,SAASL,MAK5B,IAAIQ,EAAWpB,EAEboB,EAAWpC,EACX8B,EAAaE,QAAQ,gBAAkBhB,EAGzC,MAAMqB,QAAiBC,MAAMF,EAAUN,GAEvC,IAAKO,EAASE,GACZ,MAAM,IAAIG,MAAM,2BAA2BL,EAASM,UAItD,aADqBN,EAASO,QAChBsB,QAAU,EAC1B,CAAE,MAAOrB,GAEP,MADAC,QAAQD,MAAM,iCAAkCA,GAC1CA,CACR,CACF,G,SC/RA,MAAMsB,EACe,mBADfA,EAEW,eAFXA,EAGe,kBAHfA,EAIqB,wBAJrBA,EAKY,eALZA,EAMqB,wBANrBA,EAOc,iBAiDpB/D,eAAegE,IACb,OAAO,IAAIC,QAASC,IAoBlBA,EAnBiB,CACf/D,UACEgE,OAAOC,QAAQC,gBAAgBC,IAAIP,IACnC,GACF3D,MACE+D,OAAOC,QAAQC,gBAAgBC,IAAIP,IAA+B,GACpE1D,SACE8D,OAAOC,QAAQC,gBAAgBC,IAAIP,IACnC,GACFQ,gBACEJ,OAAOC,QAAQC,gBAAgBC,IAC7BP,IACG,+BACPS,SAEE,IADAL,OAAOC,QAAQC,gBAAgBC,IAAIP,GAErCzD,QACE6D,OAAOC,QAAQC,gBAAgBC,IAAIP,IAAkC,MAI7E,CA2FqClE,EAAOC,UAC1CD,EAAOC,QAAU,CACf2E,aA7JJzE,eAA4B0E,GAC1B,OAAO,IAAIT,QAAQ,CAACC,EAASS,KAC3BR,OAAOC,QAAQC,gBAAgBO,IAC7Bb,EACAW,EAASvE,WAAa,IAExBgE,OAAOC,QAAQC,gBAAgBO,IAC7Bb,EACAW,EAAStE,OAAS,IAEpB+D,OAAOC,QAAQC,gBAAgBO,IAC7Bb,EACAW,EAASrE,UAAY,IAEvB8D,OAAOC,QAAQC,gBAAgBO,IAC7Bb,EACAW,EAASH,iBAAmB,gCAE9BJ,OAAOC,QAAQC,gBAAgBO,IAC7Bb,GACqB,IAArBW,EAASF,SAEXL,OAAOC,QAAQC,gBAAgBO,IAC7Bb,EACAW,EAASpE,SAAW,IAGtB6D,OAAOC,QAAQC,gBAAgBQ,UAAWC,IACpCA,EAAOvC,SAAW4B,OAAOY,kBAAkBC,UAC7Cd,IAEAS,EAAO,IAAIrC,MAAM,4BAA8BwC,EAAOrC,MAAMwC,aAIpE,EA2HIjB,eACAkB,aAzFJlF,iBACE,MAAM0E,QAAiBV,IACvB,SAAUU,EAASvE,WAAauE,EAAStE,OAASsE,EAASrE,SAC7D,EAuFI8E,cAjFJnF,iBACE,OAAO,IAAIiE,QAAQ,CAACC,EAASS,KAC3BR,OAAOC,QAAQC,gBAAgBe,OAAOrB,GACtCI,OAAOC,QAAQC,gBAAgBe,OAAOrB,GACtCI,OAAOC,QAAQC,gBAAgBe,OAAOrB,GACtCI,OAAOC,QAAQC,gBAAgBe,OAAOrB,GACtCI,OAAOC,QAAQC,gBAAgBe,OAAOrB,GAEtCI,OAAOC,QAAQC,gBAAgBQ,UAAWC,IACpCA,EAAOvC,SAAW4B,OAAOY,kBAAkBC,UAC7Cd,IAEAS,EAAO,IAAIrC,MAAM,6BAA+BwC,EAAOrC,MAAMwC,aAIrE,EAkEII,8BAxCJrF,eAA6CsF,EAAgB1C,GAC3D,OAAO,IAAIqB,QAAQ,CAACC,EAASS,KAE3B,MAAMY,EAAWpB,OAAOC,QAAQC,gBAAgBC,IAAIP,IAAyC,CAAC,EAG9FwB,EAASD,GAAkB1C,EAG3BuB,OAAOC,QAAQC,gBAAgBO,IAAIb,EAAsCwB,GAEzEpB,OAAOC,QAAQC,gBAAgBQ,UAAWC,IACpCA,EAAOvC,SAAW4B,OAAOY,kBAAkBC,UAC7Cd,IAEAS,EAAO,IAAIrC,MAAM,wCAA0CwC,EAAOrC,MAAMwC,aAIhF,EAsBIO,yBAfJxF,eAAwCsF,GACtC,OAAO,IAAIrB,QAASC,IAElBA,GADiBC,OAAOC,QAAQC,gBAAgBC,IAAIP,IAAyC,CAAC,GAC7EuB,IAAmB,OAExC,EAWIG,0BA9DJzF,iBACE,OAAO,IAAIiE,QAAQ,CAACC,EAASS,KAC3BR,OAAOC,QAAQC,gBAAgBe,OAAOrB,GAEtCI,OAAOC,QAAQC,gBAAgBQ,UAAWC,IACpCA,EAAOvC,SAAW4B,OAAOY,kBAAkBC,UAC7Cd,IAEAS,EAAO,IAAIrC,MAAM,6BAA+BwC,EAAOrC,MAAMwC,aAIrE,G,GCnIIS,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAa/F,QAGrB,IAAID,EAAS6F,EAAyBE,GAAY,CAGjD9F,QAAS,CAAC,GAOX,OAHAiG,EAAoBH,GAAU/F,EAAQA,EAAOC,QAAS6F,GAG/C9F,EAAOC,OACf,CCnBA,MAAMkG,EAAU,EAAQ,KAClBC,EAAU,EAAQ,KAmMxBjG,eAAekG,EAAgBC,EAAM5F,GACnC,OAAO,IAAI0D,QAASC,IAClBiC,EAAK5F,QAAQ6F,SAAS7F,EAAUuE,IAC1BA,EAAOvC,SAAW4B,OAAOY,kBAAkBC,WAG7CtC,QAAQ2D,KAAK,yBAA0BvB,EAAOrC,OAF9CyB,OAOR,CAgIAlE,eAAesG,EAAqBC,GAClC,OAAO,IAAItC,QAAQ,CAACC,EAASS,KAC3BR,OAAOC,QAAQoC,QAAQL,KAAKM,0BAC1BF,EACCzB,IACKA,EAAOvC,SAAW4B,OAAOY,kBAAkB2B,OAU/CxC,EAAQY,EAAO6B,MAAM1D,SATnB0B,EACE,IAAIrC,MACF,qCAAuCwC,EAAOrC,MAAMwC,aAWlE,CAOA,SAAS2B,EAAiBC,EAAO5B,GAC/B,IACE,MAAM6B,EAAkB,uBAGxB3C,OAAOC,QAAQoC,QAAQL,KAAKY,qBAAqBC,YAC/CF,EACA,KAEE3C,OAAOC,QAAQoC,QAAQL,KAAKY,qBAAqBE,SAC/CH,EACA,CACEI,KAAM,uBACNjC,QAAS,GAAG4B,MAAU5B,IACtBkC,KAAM,UACNC,YAAY,KAKtB,CAAE,MAAO3E,GACPC,QAAQD,MAAM,+BAAgCA,EAChD,CACF,CA5XA0B,OAAOkD,QAAQ,QA2bflD,OAAOmD,QAAQC,UAAU,gBAnbzBvH,eAA6BwH,GAC3B9E,QAAQ+E,IAAI,iCAEZ,IAEE,MAAM/C,QAAiBsB,EAAQhC,eAE/B,IAAKU,EAASF,QAKZ,OAJA9B,QAAQ+E,IACN,2EAEFD,EAAME,UAAU,CAAEC,YAAY,IAKhC,UAD2B3B,EAAQd,eAQjC,OANAxC,QAAQ+E,IAAI,iDACZb,EACE,gCACA,mEAEFY,EAAME,UAAU,CAAEC,YAAY,IAKhC,MAAMxB,EAAOhC,OAAOC,QAAQoC,QAAQL,KAG9ByB,QAgMV5H,eAAgCmG,GAC9B,OAAO,IAAIlC,QAAQ,CAACC,EAASS,KAE3BwB,EAAK0B,GAAGC,SAAUC,IAChB,GAAIA,EAASxF,SAAW4B,OAAOY,kBAAkB2B,OAI/C,YAHA/B,EACE,IAAIrC,MAAM,6BAA+ByF,EAAStF,MAAMwC,UAK5D,MAAM+C,EAAaD,EAASpB,MAI5B,IAAIlG,EAAiB0D,OAAOC,QAAQoC,QAAQyB,YAAYC,aACpDxH,EAAgByD,OAAOC,QAAQoC,QAAQyB,YAAYE,YAEnDH,GAAcA,EAAW1G,OAAS,IACpCb,EAAiBuH,EAAW,GAAGE,aAC/BxH,EAAgBsH,EAAW,GAAGG,aAAeH,EAAW,GAAGE,cAI7D/B,EAAK3F,KAAKsH,SAAS3D,OAAOiE,aAAaC,KAAOvD,IAC5C,GAAIA,EAAOvC,SAAW4B,OAAOY,kBAAkB2B,OAI7C,YAHA/B,EACE,IAAIrC,MAAM,6BAA+BwC,EAAOrC,MAAMwC,UAK1D,MAAMzE,EAAOsE,EAAO6B,MAGpBR,EAAKmC,oBAAqBC,IACxB,GAAIA,EAAiBhG,SAAW4B,OAAOY,kBAAkB2B,OAYvD,OAVAhE,QAAQ2D,KACN,6BACAkC,EAAiB9F,MAAMwC,cAEzBf,EAAQ,CACN1D,OACAC,iBACAC,gBACA8H,YAAa,KAKjB,MAAMA,EAAcD,EAAiB5B,OAAS,GAE9CzC,EAAQ,CACN1D,OACAC,iBACAC,gBACA8H,uBAMZ,CA/P4BC,CAAiBtC,GAEzCzD,QAAQ+E,IACN,oBACAG,EAAUnH,eACVmH,EAAUlH,eAIZ,MAAM4E,EAAiBa,EAAKb,eACtBoD,QA8HV1I,eAA+BmG,GAC7B,OAAO,IAAIlC,QAASC,IAClBiC,EAAK5F,QAAQuH,SAAUhD,IACjBA,EAAOvC,SAAW4B,OAAOY,kBAAkBC,UAC7Cd,EAAQY,EAAO6B,OAAS,cAExBzC,EAAQ,iBAIhB,CAxI+ByE,CAAgBxC,GAC3CzD,QAAQ+E,IAAI,mBAAoBnC,GAChC5C,QAAQ+E,IAAI,iBAAkBiB,GAG9B,MAAME,EA8JV,SAAoCrI,GAElC,MAAMsI,EAAW,CAAC,aAAc,qBAAsB,iBAEtD,IAAK,MAAMC,KAAWD,EAAU,CAC9B,MAAME,EAAQxI,EAAQwI,MAAMD,GAC5B,GAAIC,GAASA,EAAM,GACjB,OAAO1H,SAAS0H,EAAM,GAE1B,CAEA,OAAO,IACT,CA1K8BC,CAA2BN,GACrDhG,QAAQ+E,IAAI,0BAA2BmB,GAGvC,IAAIK,EAAmB,KAGnBL,GACFK,EAAmBL,EACnBlG,QAAQ+E,IAAI,kCAAmCwB,IAGxC3D,GAA4C,KAA1BA,EAAe4D,QACxCD,QAAyBjD,EAAQR,yBAAyBF,GAC1D5C,QAAQ+E,IAAI,oCAAqCwB,IAIjDvG,QAAQ+E,IACN,oEAKJ,MAAM9G,QAgOVX,eAAiC0E,EAAU8D,GACzC,MAAMW,EAAS,GAEf,IAAK,MAAMpG,KAAcyF,EACvB,IAEE,MAAMvF,QAAgBqD,EAAqBvD,EAAWqG,IAGhDzF,QAAcsC,EAAQnD,iBAAiB4B,EAAU,CACrD1B,SAAUD,EAAW5B,KACrB8B,QAASA,IAGXkG,EAAOE,KAAK1F,GACZjB,QAAQ+E,IAAI,wBAAwB1E,EAAW5B,OACjD,CAAE,MAAOsB,GACPC,QAAQD,MAAM,+BAA+BM,EAAW5B,QAASsB,EAEnE,CAGF,OAAO0G,CACT,CAvPmCG,CAC7B5E,EACAkD,EAAUY,aAGZ,GAAIS,EAAkB,CAEpBvG,QAAQ+E,IAAI,4BAA6BwB,GAEzC,MAAMpG,EAAc,CAClBrC,KAAMoH,EAAUpH,KAChBG,iBAAkBA,GAQpB,SALMsF,EAAQtD,mBAAmB+B,EAAUuE,EAAkBpG,GAE7DH,QAAQ+E,IAAI,2BAA4BwB,IAGnCL,EAAmB,CACtB,MAAMW,EAAa,GAAGb,OAAkBO,WAClC/C,EAAgBC,EAAMoD,GAC5B7G,QAAQ+E,IAAI,oCAAqC8B,EACnD,CAGIjE,GAA4C,KAA1BA,EAAe4D,cAC7BlD,EAAQX,8BACZC,EACA2D,GAKJrC,EACE,yBACA,WAAWqC,wCAEf,KAAO,CAELvG,QAAQ+E,IAAI,wCAAyCnC,GAErD,MAAMpF,EAAa,CACjBK,QAASmE,EAASH,gBAClB/D,KAAMoH,EAAUpH,KAChBC,eAAgBmH,EAAUnH,eAC1BC,cAAekH,EAAUlH,cACzBC,iBAAkBA,GAIdiC,SADeqD,EAAQlG,aAAa2E,EAAUxE,IAC5BY,OAAOsI,GAM/B,GAJA1G,QAAQ+E,IAAI,uCAAwC7E,IAI/CgG,EAAmB,CACtB,MAAMW,EAAa,GAAGb,OAAkB9F,WAClCsD,EAAgBC,EAAMoD,GAC5B7G,QAAQ+E,IAAI,8BAA+B8B,EAC7C,CAGIjE,GAA4C,KAA1BA,EAAe4D,eAC7BlD,EAAQX,8BAA8BC,EAAgB1C,GAC5DF,QAAQ+E,IAAI,6CAIdb,EACE,yBACA,WAAWhE,mCAEf,CAGA4E,EAAME,UAAU,CAAEC,YAAY,GAChC,CAAE,MAAOlF,GACPC,QAAQD,MAAM,iCAAkCA,GAGhDmE,EACE,gBACA,4BAA8BnE,EAAMwC,SAItCuC,EAAME,UAAU,CAAEC,YAAY,GAChC,CACF,GAuRAxD,OAAOmD,QAAQC,UAAU,gBA5DzBvH,eAA6BwH,GAC3B9E,QAAQ+E,IAAI,iCAEZ,IAEE,MAAM/C,QAAiBsB,EAAQhC,eAG/BU,EAASF,SAAWE,EAASF,cAGvBwB,EAAQvB,aAAaC,GAE3BhC,QAAQ+E,IAAI,kCAAmC/C,EAASF,SAGxD,MAAMjC,EAASmC,EAASF,QAAU,UAAY,WACxCsC,EAAkB,kBAAkB0C,KAAKC,QAE/C/G,QAAQ+E,IAAI,sCAGZtD,OAAOC,QAAQoC,QAAQL,KAAKY,qBAAqBE,SAC/CH,EACA,CACEI,KAAM,uBACNjC,QAAS,WAAW1C,6BAAkCA,EAAOmH,gBAC7DvC,KAAM,UACNC,YAAY,GAEbtC,IACKA,EAAOvC,SAAW4B,OAAOY,kBAAkB2B,OAC7ChE,QAAQD,MAAM,+BAAgCqC,EAAOrC,OAErDC,QAAQ+E,IAAI,sCAMlBD,EAAME,WACR,CAAE,MAAOjF,GACPC,QAAQD,MAAM,0BAA2BA,GAEzC0B,OAAOC,QAAQoC,QAAQL,KAAKY,qBAAqBE,SAC/C,iBAAiBuC,KAAKC,QACtB,CACEvC,KAAM,eACNjC,QAAS,6BAA+BxC,EAAMwC,UAIlDuC,EAAME,WACR,CACF,E","sources":["webpack://outlook-zendesk-add-in/./src/services/zendesk.js","webpack://outlook-zendesk-add-in/./src/utils/storage.js","webpack://outlook-zendesk-add-in/webpack/bootstrap","webpack://outlook-zendesk-add-in/./src/commands/commands.js"],"sourcesContent":["/**\r\n * Zendesk API service for creating tickets and uploading attachments\r\n */\r\n\r\n// Set to true to use local CORS proxy for development (Outlook Web)\r\n// Set to false for Outlook Desktop (no CORS issues)\r\nconst USE_PROXY = true;\r\nconst PROXY_URL = \"https://06zyva2dth.execute-api.ap-northeast-1.amazonaws.com\";\r\n\r\n/**\r\n * Create a Zendesk ticket\r\n * @param {Object} credentials - Zendesk credentials\r\n * @param {Object} ticketData - Ticket data\r\n * @returns {Promise<Object>} Created ticket response\r\n */\r\nasync function createTicket(credentials, ticketData) {\r\n  const { subdomain, email, apiToken, groupId } = credentials;\r\n  const { subject, body, requesterEmail, requesterName, attachmentTokens } =\r\n    ticketData;\r\n\r\n  // Build the API URL\r\n  const apiUrl = `https://${subdomain}/api/v2/tickets.json`;\r\n\r\n  // Prepare the ticket payload\r\n  const payload = {\r\n    ticket: {\r\n      subject: subject,\r\n      comment: {\r\n        body: body,\r\n        html_body: body,\r\n        public: false,\r\n      },\r\n      requester: {\r\n        email: requesterEmail,\r\n        name: requesterName,\r\n      },\r\n    },\r\n  };\r\n\r\n  // Add group assignment if configured\r\n  if (groupId) {\r\n    payload.ticket.group_id = parseInt(groupId, 10);\r\n  }\r\n\r\n  // Add attachment tokens if present\r\n  if (attachmentTokens && attachmentTokens.length > 0) {\r\n    payload.ticket.comment.uploads = attachmentTokens;\r\n  }\r\n\r\n  // Create Basic Auth header\r\n  const authString = btoa(`${email}/token:${apiToken}`);\r\n\r\n  try {\r\n    const fetchOptions = {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: `Basic ${authString}`,\r\n      },\r\n      body: JSON.stringify(payload),\r\n    };\r\n\r\n    // Use proxy if enabled (for Outlook Web CORS workaround)\r\n    let fetchUrl = apiUrl;\r\n    if (USE_PROXY) {\r\n      fetchUrl = PROXY_URL;\r\n      fetchOptions.headers[\"X-Target-URL\"] = apiUrl;\r\n    }\r\n\r\n    const response = await fetch(fetchUrl, fetchOptions);\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Zendesk API error (${response.status}): ${errorText}`);\r\n    }\r\n\r\n    const result = await response.json();\r\n    return result;\r\n  } catch (error) {\r\n    console.error(\"Error creating Zendesk ticket:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Add a comment to an existing Zendesk ticket\r\n * @param {Object} credentials - Zendesk credentials\r\n * @param {number} ticketId - Existing ticket ID\r\n * @param {Object} commentData - Comment data\r\n * @returns {Promise<Object>} Updated ticket response\r\n */\r\nasync function addCommentToTicket(credentials, ticketId, commentData) {\r\n  const { subdomain, email, apiToken } = credentials;\r\n  const { body, attachmentTokens } = commentData;\r\n\r\n  // Build the API URL\r\n  const apiUrl = `https://${subdomain}/api/v2/tickets/${ticketId}.json`;\r\n\r\n  // Prepare the update payload\r\n  const payload = {\r\n    ticket: {\r\n      comment: {\r\n        body: body,\r\n        html_body: body,\r\n        public: false, // Internal note\r\n      },\r\n    },\r\n  };\r\n\r\n  // Add attachment tokens if present\r\n  if (attachmentTokens && attachmentTokens.length > 0) {\r\n    payload.ticket.comment.uploads = attachmentTokens;\r\n  }\r\n\r\n  // Create Basic Auth header\r\n  const authString = btoa(`${email}/token:${apiToken}`);\r\n\r\n  try {\r\n    const fetchOptions = {\r\n      method: \"PUT\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: `Basic ${authString}`,\r\n      },\r\n      body: JSON.stringify(payload),\r\n    };\r\n\r\n    // Use proxy if enabled (for Outlook Web CORS workaround)\r\n    let fetchUrl = apiUrl;\r\n    if (USE_PROXY) {\r\n      fetchUrl = PROXY_URL;\r\n      fetchOptions.headers[\"X-Target-URL\"] = apiUrl;\r\n    }\r\n\r\n    const response = await fetch(fetchUrl, fetchOptions);\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Zendesk API error (${response.status}): ${errorText}`);\r\n    }\r\n\r\n    const result = await response.json();\r\n    return result;\r\n  } catch (error) {\r\n    console.error(\"Error adding comment to Zendesk ticket:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Upload an attachment to Zendesk\r\n * @param {Object} credentials - Zendesk credentials\r\n * @param {Object} attachment - Attachment data\r\n * @returns {Promise<string>} Upload token\r\n */\r\nasync function uploadAttachment(credentials, attachment) {\r\n  const { subdomain, email, apiToken } = credentials;\r\n  const { filename, content } = attachment;\r\n\r\n  // Build the API URL with filename\r\n  const apiUrl = `https://${subdomain}/api/v2/uploads.json?filename=${encodeURIComponent(\r\n    filename,\r\n  )}`;\r\n\r\n  // Create Basic Auth header\r\n  const authString = btoa(`${email}/token:${apiToken}`);\r\n\r\n  try {\r\n    // Convert base64 to binary if needed\r\n    let binaryContent;\r\n    if (typeof content === \"string\") {\r\n      // Assume base64 encoded\r\n      const binaryString = atob(content);\r\n      const bytes = new Uint8Array(binaryString.length);\r\n      for (let i = 0; i < binaryString.length; i++) {\r\n        bytes[i] = binaryString.charCodeAt(i);\r\n      }\r\n      binaryContent = bytes;\r\n    } else {\r\n      binaryContent = content;\r\n    }\r\n\r\n    const fetchOptions = {\r\n      method: \"POST\",\r\n      headers: {\r\n        Authorization: `Basic ${authString}`,\r\n        \"Content-Type\": \"application/binary\",\r\n      },\r\n      body: binaryContent,\r\n    };\r\n\r\n    // Use proxy if enabled (for Outlook Web CORS workaround)\r\n    let fetchUrl = apiUrl;\r\n    if (USE_PROXY) {\r\n      fetchUrl = PROXY_URL;\r\n      fetchOptions.headers[\"X-Target-URL\"] = apiUrl;\r\n    }\r\n\r\n    const response = await fetch(fetchUrl, fetchOptions);\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(\r\n        `Failed to upload attachment (${response.status}): ${errorText}`,\r\n      );\r\n    }\r\n\r\n    const result = await response.json();\r\n    return result.upload.token;\r\n  } catch (error) {\r\n    console.error(\"Error uploading attachment:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Test Zendesk connection\r\n * @param {Object} credentials - Zendesk credentials\r\n * @returns {Promise<boolean>} True if connection is successful\r\n */\r\nasync function testConnection(credentials) {\r\n  const { subdomain, email, apiToken } = credentials;\r\n\r\n  // Note: For development, CORS will block direct API calls from localhost\r\n  // In production, use a backend proxy or Outlook Desktop (which doesn't have CORS restrictions)\r\n  const apiUrl = `https://${subdomain}/api/v2/users/me.json`;\r\n\r\n  const authString = btoa(`${email}/token:${apiToken}`);\r\n\r\n  try {\r\n    const fetchOptions = {\r\n      method: \"GET\",\r\n      headers: {\r\n        Authorization: `Basic ${authString}`,\r\n      },\r\n    };\r\n\r\n    // Use proxy if enabled (for Outlook Web CORS workaround)\r\n    let fetchUrl = apiUrl;\r\n    if (USE_PROXY) {\r\n      fetchUrl = PROXY_URL;\r\n      fetchOptions.headers[\"X-Target-URL\"] = apiUrl;\r\n    }\r\n\r\n    const response = await fetch(fetchUrl, fetchOptions);\r\n\r\n    return response.ok;\r\n  } catch (error) {\r\n    console.error(\"Error testing Zendesk connection:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Fetch all groups from Zendesk\r\n * @param {Object} credentials - Zendesk credentials\r\n * @returns {Promise<Array>} Array of groups\r\n */\r\nasync function fetchGroups(credentials) {\r\n  const { subdomain, email, apiToken } = credentials;\r\n\r\n  const apiUrl = `https://${subdomain}/api/v2/groups.json`;\r\n  const authString = btoa(`${email}/token:${apiToken}`);\r\n\r\n  try {\r\n    const fetchOptions = {\r\n      method: \"GET\",\r\n      headers: {\r\n        Authorization: `Basic ${authString}`,\r\n      },\r\n    };\r\n\r\n    // Use proxy if enabled (for Outlook Web CORS workaround)\r\n    let fetchUrl = apiUrl;\r\n    if (USE_PROXY) {\r\n      fetchUrl = PROXY_URL;\r\n      fetchOptions.headers[\"X-Target-URL\"] = apiUrl;\r\n    }\r\n\r\n    const response = await fetch(fetchUrl, fetchOptions);\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch groups: ${response.status}`);\r\n    }\r\n\r\n    const result = await response.json();\r\n    return result.groups || [];\r\n  } catch (error) {\r\n    console.error(\"Error fetching Zendesk groups:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Export for use in other modules\r\nif (typeof module !== \"undefined\" && module.exports) {\r\n  module.exports = {\r\n    createTicket,\r\n    addCommentToTicket,\r\n    uploadAttachment,\r\n    testConnection,\r\n    fetchGroups,\r\n  };\r\n}\r\n","/**\r\n * Storage utility for managing Zendesk credentials using Office.RoamingSettings\r\n */\r\n\r\nconst STORAGE_KEYS = {\r\n  ZENDESK_SUBDOMAIN: \"zendeskSubdomain\",\r\n  ZENDESK_EMAIL: \"zendeskEmail\",\r\n  ZENDESK_API_TOKEN: \"zendeskApiToken\",\r\n  TICKET_SUBJECT_TEMPLATE: \"ticketSubjectTemplate\",\r\n  ADD_IN_ENABLED: \"addInEnabled\",\r\n  CONVERSATION_TICKET_MAP: \"conversationTicketMap\",\r\n  ZENDESK_GROUP_ID: \"zendeskGroupId\",\r\n};\r\n\r\n/**\r\n * Save settings to Office roaming settings\r\n * @param {Object} settings - Settings object containing credentials\r\n * @returns {Promise<void>}\r\n */\r\nasync function saveSettings(settings) {\r\n  return new Promise((resolve, reject) => {\r\n    Office.context.roamingSettings.set(\r\n      STORAGE_KEYS.ZENDESK_SUBDOMAIN,\r\n      settings.subdomain || \"\"\r\n    );\r\n    Office.context.roamingSettings.set(\r\n      STORAGE_KEYS.ZENDESK_EMAIL,\r\n      settings.email || \"\"\r\n    );\r\n    Office.context.roamingSettings.set(\r\n      STORAGE_KEYS.ZENDESK_API_TOKEN,\r\n      settings.apiToken || \"\"\r\n    );\r\n    Office.context.roamingSettings.set(\r\n      STORAGE_KEYS.TICKET_SUBJECT_TEMPLATE,\r\n      settings.subjectTemplate || \"Support Request from Outlook\"\r\n    );\r\n    Office.context.roamingSettings.set(\r\n      STORAGE_KEYS.ADD_IN_ENABLED,\r\n      settings.enabled !== false\r\n    );\r\n    Office.context.roamingSettings.set(\r\n      STORAGE_KEYS.ZENDESK_GROUP_ID,\r\n      settings.groupId || \"\"\r\n    );\r\n\r\n    Office.context.roamingSettings.saveAsync((result) => {\r\n      if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(\"Failed to save settings: \" + result.error.message));\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Load settings from Office roaming settings\r\n * @returns {Promise<Object>} Settings object\r\n */\r\nasync function loadSettings() {\r\n  return new Promise((resolve) => {\r\n    const settings = {\r\n      subdomain:\r\n        Office.context.roamingSettings.get(STORAGE_KEYS.ZENDESK_SUBDOMAIN) ||\r\n        \"\",\r\n      email:\r\n        Office.context.roamingSettings.get(STORAGE_KEYS.ZENDESK_EMAIL) || \"\",\r\n      apiToken:\r\n        Office.context.roamingSettings.get(STORAGE_KEYS.ZENDESK_API_TOKEN) ||\r\n        \"\",\r\n      subjectTemplate:\r\n        Office.context.roamingSettings.get(\r\n          STORAGE_KEYS.TICKET_SUBJECT_TEMPLATE\r\n        ) || \"Support Request from Outlook\",\r\n      enabled:\r\n        Office.context.roamingSettings.get(STORAGE_KEYS.ADD_IN_ENABLED) !==\r\n        false,\r\n      groupId:\r\n        Office.context.roamingSettings.get(STORAGE_KEYS.ZENDESK_GROUP_ID) || \"\",\r\n    };\r\n    resolve(settings);\r\n  });\r\n}\r\n\r\n/**\r\n * Check if credentials are configured\r\n * @returns {Promise<boolean>}\r\n */\r\nasync function isConfigured() {\r\n  const settings = await loadSettings();\r\n  return !!(settings.subdomain && settings.email && settings.apiToken);\r\n}\r\n\r\n/**\r\n * Clear all settings\r\n * @returns {Promise<void>}\r\n */\r\nasync function clearSettings() {\r\n  return new Promise((resolve, reject) => {\r\n    Office.context.roamingSettings.remove(STORAGE_KEYS.ZENDESK_SUBDOMAIN);\r\n    Office.context.roamingSettings.remove(STORAGE_KEYS.ZENDESK_EMAIL);\r\n    Office.context.roamingSettings.remove(STORAGE_KEYS.ZENDESK_API_TOKEN);\r\n    Office.context.roamingSettings.remove(STORAGE_KEYS.TICKET_SUBJECT_TEMPLATE);\r\n    Office.context.roamingSettings.remove(STORAGE_KEYS.ADD_IN_ENABLED);\r\n\r\n    Office.context.roamingSettings.saveAsync((result) => {\r\n      if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(\"Failed to clear settings: \" + result.error.message));\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Clear conversation-ticket mappings\r\n * @returns {Promise<void>}\r\n */\r\nasync function clearConversationMappings() {\r\n  return new Promise((resolve, reject) => {\r\n    Office.context.roamingSettings.remove(STORAGE_KEYS.CONVERSATION_TICKET_MAP);\r\n\r\n    Office.context.roamingSettings.saveAsync((result) => {\r\n      if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(\"Failed to clear mappings: \" + result.error.message));\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Save conversation to ticket mapping\r\n * @param {string} conversationId - Outlook conversation ID\r\n * @param {number} ticketId - Zendesk ticket ID\r\n * @returns {Promise<void>}\r\n */\r\nasync function saveConversationTicketMapping(conversationId, ticketId) {\r\n  return new Promise((resolve, reject) => {\r\n    // Get existing mappings\r\n    const mappings = Office.context.roamingSettings.get(STORAGE_KEYS.CONVERSATION_TICKET_MAP) || {};\r\n\r\n    // Add new mapping\r\n    mappings[conversationId] = ticketId;\r\n\r\n    // Save back\r\n    Office.context.roamingSettings.set(STORAGE_KEYS.CONVERSATION_TICKET_MAP, mappings);\r\n\r\n    Office.context.roamingSettings.saveAsync((result) => {\r\n      if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(\"Failed to save conversation mapping: \" + result.error.message));\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Get ticket ID for a conversation\r\n * @param {string} conversationId - Outlook conversation ID\r\n * @returns {Promise<number|null>} Zendesk ticket ID or null if not found\r\n */\r\nasync function getTicketForConversation(conversationId) {\r\n  return new Promise((resolve) => {\r\n    const mappings = Office.context.roamingSettings.get(STORAGE_KEYS.CONVERSATION_TICKET_MAP) || {};\r\n    resolve(mappings[conversationId] || null);\r\n  });\r\n}\r\n\r\n// Export for use in other modules\r\nif (typeof module !== \"undefined\" && module.exports) {\r\n  module.exports = {\r\n    saveSettings,\r\n    loadSettings,\r\n    isConfigured,\r\n    clearSettings,\r\n    saveConversationTicketMapping,\r\n    getTicketForConversation,\r\n    clearConversationMappings,\r\n  };\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/* global Office */\r\n\r\n// Import utilities\r\nconst storage = require(\"../utils/storage\");\r\nconst zendesk = require(\"../services/zendesk\");\r\n\r\n// Initialize Office\r\nOffice.onReady(() => {\r\n  // Register event handlers\r\n});\r\n\r\n/**\r\n * Handle the OnMessageSend event\r\n * This function is called when a user attempts to send an email\r\n */\r\nasync function onMessageSend(event) {\r\n  console.log(\"OnMessageSend event triggered\");\r\n\r\n  try {\r\n    // Check if add-in is configured and enabled\r\n    const settings = await storage.loadSettings();\r\n\r\n    if (!settings.enabled) {\r\n      console.log(\r\n        \"Add-in is disabled, allowing email to send without creating ticket\",\r\n      );\r\n      event.completed({ allowEvent: true });\r\n      return;\r\n    }\r\n\r\n    const isConfigured = await storage.isConfigured();\r\n    if (!isConfigured) {\r\n      console.log(\"Add-in not configured, allowing email to send\");\r\n      showNotification(\r\n        \"Zendesk add-in not configured\",\r\n        \"Please configure the Zendesk add-in before sending emails.\",\r\n      );\r\n      event.completed({ allowEvent: true });\r\n      return;\r\n    }\r\n\r\n    // Get the current mail item\r\n    const item = Office.context.mailbox.item;\r\n\r\n    // Extract email data\r\n    const emailData = await extractEmailData(item);\r\n\r\n    console.log(\r\n      \"Ticket requester:\",\r\n      emailData.requesterEmail,\r\n      emailData.requesterName,\r\n    );\r\n\r\n    // Get conversation ID and subject\r\n    const conversationId = item.conversationId;\r\n    const emailSubject = await getEmailSubject(item);\r\n    console.log(\"Conversation ID:\", conversationId);\r\n    console.log(\"Email Subject:\", emailSubject);\r\n\r\n    // Try to extract ticket ID from subject line [#123]\r\n    const ticketFromSubject = extractTicketIdFromSubject(emailSubject);\r\n    console.log(\"Ticket ID from subject:\", ticketFromSubject);\r\n\r\n    // Check if this is a reply to an existing conversation\r\n    let existingTicketId = null;\r\n\r\n    // First priority: Check if ticket ID is in the subject line\r\n    if (ticketFromSubject) {\r\n      existingTicketId = ticketFromSubject;\r\n      console.log(\"Using ticket from subject line:\", existingTicketId);\r\n    }\r\n    // Second priority: Check by conversationId\r\n    else if (conversationId && conversationId.trim() !== \"\") {\r\n      existingTicketId = await storage.getTicketForConversation(conversationId);\r\n      console.log(\"Existing ticket for conversation:\", existingTicketId);\r\n    }\r\n    // No match: This is a NEW email\r\n    else {\r\n      console.log(\r\n        \"No ticket ID found - this is a new email, will create new ticket\",\r\n      );\r\n    }\r\n\r\n    // Upload attachments first\r\n    const attachmentTokens = await uploadAttachments(\r\n      settings,\r\n      emailData.attachments,\r\n    );\r\n\r\n    if (existingTicketId) {\r\n      // Update existing ticket with a new comment\r\n      console.log(\"Updating existing ticket:\", existingTicketId);\r\n\r\n      const commentData = {\r\n        body: emailData.body,\r\n        attachmentTokens: attachmentTokens,\r\n      };\r\n\r\n      await zendesk.addCommentToTicket(settings, existingTicketId, commentData);\r\n\r\n      console.log(\"Comment added to ticket:\", existingTicketId);\r\n\r\n      // Ensure ticket ID is in the subject (in case it was removed or this is a reply)\r\n      if (!ticketFromSubject) {\r\n        const newSubject = `${emailSubject} [#${existingTicketId}]`;\r\n        await setEmailSubject(item, newSubject);\r\n        console.log(\"Added ticket ID to reply subject:\", newSubject);\r\n      }\r\n\r\n      // Update conversation mapping if we now have a conversationId\r\n      if (conversationId && conversationId.trim() !== \"\") {\r\n        await storage.saveConversationTicketMapping(\r\n          conversationId,\r\n          existingTicketId,\r\n        );\r\n      }\r\n\r\n      // Show success notification\r\n      showNotification(\r\n        \"Zendesk Ticket Updated\",\r\n        `Ticket #${existingTicketId} has been updated with your message.`,\r\n      );\r\n    } else {\r\n      // Create new Zendesk ticket\r\n      console.log(\"Creating new ticket for conversation:\", conversationId);\r\n\r\n      const ticketData = {\r\n        subject: settings.subjectTemplate,\r\n        body: emailData.body,\r\n        requesterEmail: emailData.requesterEmail,\r\n        requesterName: emailData.requesterName,\r\n        attachmentTokens: attachmentTokens,\r\n      };\r\n\r\n      const result = await zendesk.createTicket(settings, ticketData);\r\n      const ticketId = result.ticket.id;\r\n\r\n      console.log(\"Zendesk ticket created successfully:\", ticketId);\r\n\r\n      // Add ticket ID to the email subject so replies can be tracked\r\n      // Check if subject already has a ticket ID (to avoid duplicates)\r\n      if (!ticketFromSubject) {\r\n        const newSubject = `${emailSubject} [#${ticketId}]`;\r\n        await setEmailSubject(item, newSubject);\r\n        console.log(\"Added ticket ID to subject:\", newSubject);\r\n      }\r\n\r\n      // Save the conversation-to-ticket mapping (if conversationId is available)\r\n      if (conversationId && conversationId.trim() !== \"\") {\r\n        await storage.saveConversationTicketMapping(conversationId, ticketId);\r\n        console.log(\"Saved ticket mapping with conversationId\");\r\n      }\r\n\r\n      // Show success notification\r\n      showNotification(\r\n        \"Zendesk Ticket Created\",\r\n        `Ticket #${ticketId} has been created successfully.`,\r\n      );\r\n    }\r\n\r\n    // Allow the email to be sent\r\n    event.completed({ allowEvent: true });\r\n  } catch (error) {\r\n    console.error(\"Error creating Zendesk ticket:\", error);\r\n\r\n    // Show error notification but still allow email to send\r\n    showNotification(\r\n      \"Zendesk Error\",\r\n      \"Failed to create ticket: \" + error.message,\r\n    );\r\n\r\n    // Allow the email to be sent even if ticket creation failed\r\n    event.completed({ allowEvent: true });\r\n  }\r\n}\r\n\r\n/**\r\n * Get email subject\r\n * @param {Office.MessageCompose} item - The mail item\r\n * @returns {Promise<string>} Email subject\r\n */\r\nasync function getEmailSubject(item) {\r\n  return new Promise((resolve) => {\r\n    item.subject.getAsync((result) => {\r\n      if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n        resolve(result.value || \"No Subject\");\r\n      } else {\r\n        resolve(\"No Subject\");\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Set email subject\r\n * @param {Office.MessageCompose} item - The mail item\r\n * @param {string} subject - New subject\r\n * @returns {Promise<void>}\r\n */\r\nasync function setEmailSubject(item, subject) {\r\n  return new Promise((resolve) => {\r\n    item.subject.setAsync(subject, (result) => {\r\n      if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n        resolve();\r\n      } else {\r\n        console.warn(\"Failed to set subject:\", result.error);\r\n        resolve(); // Don't fail the whole process\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Extract ticket ID from subject line\r\n * Looks for patterns like [#123] or [Ticket #123]\r\n * @param {string} subject - Email subject\r\n * @returns {number|null} Ticket ID or null\r\n */\r\nfunction extractTicketIdFromSubject(subject) {\r\n  // Match patterns: [#123], [Ticket #123], [ZD#123]\r\n  const patterns = [/\\[#(\\d+)\\]/, /\\[Ticket #(\\d+)\\]/i, /\\[ZD#(\\d+)\\]/i];\r\n\r\n  for (const pattern of patterns) {\r\n    const match = subject.match(pattern);\r\n    if (match && match[1]) {\r\n      return parseInt(match[1]);\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Extract email data from the mail item\r\n * @param {Office.MessageCompose} item - The mail item\r\n * @returns {Promise<Object>} Email data\r\n */\r\nasync function extractEmailData(item) {\r\n  return new Promise((resolve, reject) => {\r\n    // Get recipients (TO field)\r\n    item.to.getAsync((toResult) => {\r\n      if (toResult.status === Office.AsyncResultStatus.Failed) {\r\n        reject(\r\n          new Error(\"Failed to get recipients: \" + toResult.error.message),\r\n        );\r\n        return;\r\n      }\r\n\r\n      const recipients = toResult.value;\r\n\r\n      // Use first recipient as the requester\r\n      // If no recipients, fall back to sender\r\n      let requesterEmail = Office.context.mailbox.userProfile.emailAddress;\r\n      let requesterName = Office.context.mailbox.userProfile.displayName;\r\n\r\n      if (recipients && recipients.length > 0) {\r\n        requesterEmail = recipients[0].emailAddress;\r\n        requesterName = recipients[0].displayName || recipients[0].emailAddress;\r\n      }\r\n\r\n      // Get email body\r\n      item.body.getAsync(Office.CoercionType.Html, (result) => {\r\n        if (result.status === Office.AsyncResultStatus.Failed) {\r\n          reject(\r\n            new Error(\"Failed to get email body: \" + result.error.message),\r\n          );\r\n          return;\r\n        }\r\n\r\n        const body = result.value;\r\n\r\n        // Get attachments\r\n        item.getAttachmentsAsync((attachmentResult) => {\r\n          if (attachmentResult.status === Office.AsyncResultStatus.Failed) {\r\n            // If we can't get attachments, continue without them\r\n            console.warn(\r\n              \"Failed to get attachments:\",\r\n              attachmentResult.error.message,\r\n            );\r\n            resolve({\r\n              body,\r\n              requesterEmail,\r\n              requesterName,\r\n              attachments: [],\r\n            });\r\n            return;\r\n          }\r\n\r\n          const attachments = attachmentResult.value || [];\r\n\r\n          resolve({\r\n            body,\r\n            requesterEmail,\r\n            requesterName,\r\n            attachments,\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Upload attachments to Zendesk\r\n * @param {Object} settings - Zendesk settings\r\n * @param {Array} attachments - Array of attachment objects\r\n * @returns {Promise<Array<string>>} Array of upload tokens\r\n */\r\nasync function uploadAttachments(settings, attachments) {\r\n  const tokens = [];\r\n\r\n  for (const attachment of attachments) {\r\n    try {\r\n      // Get attachment content\r\n      const content = await getAttachmentContent(attachment.id);\r\n\r\n      // Upload to Zendesk\r\n      const token = await zendesk.uploadAttachment(settings, {\r\n        filename: attachment.name,\r\n        content: content,\r\n      });\r\n\r\n      tokens.push(token);\r\n      console.log(`Uploaded attachment: ${attachment.name}`);\r\n    } catch (error) {\r\n      console.error(`Failed to upload attachment ${attachment.name}:`, error);\r\n      // Continue with other attachments even if one fails\r\n    }\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\n/**\r\n * Get attachment content as base64\r\n * @param {string} attachmentId - The attachment ID\r\n * @returns {Promise<string>} Base64 encoded content\r\n */\r\nasync function getAttachmentContent(attachmentId) {\r\n  return new Promise((resolve, reject) => {\r\n    Office.context.mailbox.item.getAttachmentContentAsync(\r\n      attachmentId,\r\n      (result) => {\r\n        if (result.status === Office.AsyncResultStatus.Failed) {\r\n          reject(\r\n            new Error(\r\n              \"Failed to get attachment content: \" + result.error.message,\r\n            ),\r\n          );\r\n          return;\r\n        }\r\n\r\n        // Content is already in base64 format\r\n        resolve(result.value.content);\r\n      },\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Show a notification to the user\r\n * @param {string} title - Notification title\r\n * @param {string} message - Notification message\r\n */\r\nfunction showNotification(title, message) {\r\n  try {\r\n    const notificationKey = \"zendesk-notification\";\r\n\r\n    // Remove any existing notification with this key first\r\n    Office.context.mailbox.item.notificationMessages.removeAsync(\r\n      notificationKey,\r\n      () => {\r\n        // After removing (or if it doesn't exist), add the new notification\r\n        Office.context.mailbox.item.notificationMessages.addAsync(\r\n          notificationKey,\r\n          {\r\n            type: \"informationalMessage\",\r\n            message: `${title}: ${message}`,\r\n            icon: \"icon-16\",\r\n            persistent: false,\r\n          },\r\n        );\r\n      },\r\n    );\r\n  } catch (error) {\r\n    console.error(\"Failed to show notification:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Toggle Zendesk integration on/off\r\n * This function is called when user clicks the toggle button\r\n */\r\nasync function toggleZendesk(event) {\r\n  console.log(\"Toggle Zendesk button clicked\");\r\n\r\n  try {\r\n    // Load current settings\r\n    const settings = await storage.loadSettings();\r\n\r\n    // Toggle the enabled state\r\n    settings.enabled = !settings.enabled;\r\n\r\n    // Save the updated settings\r\n    await storage.saveSettings(settings);\r\n\r\n    console.log(\"Zendesk integration toggled to:\", settings.enabled);\r\n\r\n    // Prepare notification message\r\n    const status = settings.enabled ? \"Enabled\" : \"Disabled\";\r\n    const notificationKey = `zendesk-toggle-${Date.now()}`; // Unique key each time\r\n\r\n    console.log(\"Attempting to show notification...\");\r\n\r\n    // Show notification directly (no need to wait since this is ExecuteFunction, not OnMessageSend)\r\n    Office.context.mailbox.item.notificationMessages.addAsync(\r\n      notificationKey,\r\n      {\r\n        type: \"informationalMessage\",\r\n        message: `Zendesk ${status}: Ticket creation is now ${status.toLowerCase()}`,\r\n        icon: \"icon-16\",\r\n        persistent: false,\r\n      },\r\n      (result) => {\r\n        if (result.status === Office.AsyncResultStatus.Failed) {\r\n          console.error(\"Failed to show notification:\", result.error);\r\n        } else {\r\n          console.log(\"Notification shown successfully!\");\r\n        }\r\n      },\r\n    );\r\n\r\n    // For ExecuteFunction commands, just call event.completed() with no parameters\r\n    event.completed();\r\n  } catch (error) {\r\n    console.error(\"Error toggling Zendesk:\", error);\r\n\r\n    Office.context.mailbox.item.notificationMessages.addAsync(\r\n      `zendesk-error-${Date.now()}`,\r\n      {\r\n        type: \"errorMessage\",\r\n        message: \"Failed to toggle Zendesk: \" + error.message,\r\n      },\r\n    );\r\n\r\n    event.completed();\r\n  }\r\n}\r\n\r\n// Register the function for the OnMessageSend event\r\nOffice.actions.associate(\"onMessageSend\", onMessageSend);\r\n\r\n// Register the toggle function\r\nOffice.actions.associate(\"toggleZendesk\", toggleZendesk);\r\n"],"names":["PROXY_URL","module","exports","createTicket","async","credentials","ticketData","subdomain","email","apiToken","groupId","subject","body","requesterEmail","requesterName","attachmentTokens","apiUrl","payload","ticket","comment","html_body","public","requester","name","group_id","parseInt","length","uploads","authString","btoa","fetchOptions","method","headers","Authorization","JSON","stringify","fetchUrl","response","fetch","ok","errorText","text","Error","status","json","error","console","addCommentToTicket","ticketId","commentData","uploadAttachment","attachment","filename","content","encodeURIComponent","binaryContent","binaryString","atob","bytes","Uint8Array","i","charCodeAt","upload","token","testConnection","fetchGroups","groups","STORAGE_KEYS","loadSettings","Promise","resolve","Office","context","roamingSettings","get","subjectTemplate","enabled","saveSettings","settings","reject","set","saveAsync","result","AsyncResultStatus","Succeeded","message","isConfigured","clearSettings","remove","saveConversationTicketMapping","conversationId","mappings","getTicketForConversation","clearConversationMappings","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","storage","zendesk","setEmailSubject","item","setAsync","warn","getAttachmentContent","attachmentId","mailbox","getAttachmentContentAsync","Failed","value","showNotification","title","notificationKey","notificationMessages","removeAsync","addAsync","type","icon","persistent","onReady","actions","associate","event","log","completed","allowEvent","emailData","to","getAsync","toResult","recipients","userProfile","emailAddress","displayName","CoercionType","Html","getAttachmentsAsync","attachmentResult","attachments","extractEmailData","emailSubject","getEmailSubject","ticketFromSubject","patterns","pattern","match","extractTicketIdFromSubject","existingTicketId","trim","tokens","id","push","uploadAttachments","newSubject","Date","now","toLowerCase"],"ignoreList":[],"sourceRoot":""}